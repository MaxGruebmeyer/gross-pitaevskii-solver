# Gross-Pitaevskii Equation (GPE) Solver

This project implements and analyzes numerical methods for finding the ground
state solution of the two-dimensional **Gross-Pitaevskii Equation (GPE)**.
The GPE is a nonlinear partial differential equation (PDE) used to model the behavior
of Bose-Einstein condensates (BECs). This project reformulates the PDE into
a nonlinear eigenvalue problem, which is then solved using various iterative
algorithms which have been presented in [JKM12](https://arxiv.org/abs/1212.0417)
and further discussed in [Hen24](https://arxiv.org/abs/2202.07593).

## Motivation

The ground state of the GPE corresponds to the solution with the minimum energy.
Finding this solution is crucial for understanding the properties of BECs,
such as their density profile and stability. Direct iterative methods can be
unstable or slow to converge, especially for strong inter-particel interactions
(high nonlinearity). This project explores and compares three common inverse
iteration approaches to find a robust and efficient solution method.

## Numerical approach

As discussed in [Hen24](https://arxiv.org/abs/2202.07593) the continous PDE
can be reformulated as an infinite-dimensional nonlinear eigenvalue problem
of the form:

$$
A(u)u = \lambda u
$$

where

- $u$ is the solution vector representing the wavefunction on the grid
- $A(u)$ is a nonlinear operator that depends on the solution itself
- $\lambda$ is the chemical potential (eigenvalue)

The eigenvalues $\lambda$ are all positive and the eigenfunction $u$ with the
minimal $\lambda$ corresponds to the solution with the minimum energy.

By discretizing this problem on a Cartesian grid using the **finite-difference
method** we can solve it using various iterative algorithms:

- **Inverse Iteration (A-Method)**: The generalized version of the inverse iteration
algorithm used in numerical linear algebra to find the smallest eigenvector
of an operator. It linearizes the problem in each step by just plugging in
$u_n$ into the function $A$.
For nonlinear problems, it can suffer from instability and failure
to converge for high nonlinearity.
- **Dampened Inverse Iteration**:
An enhanced method based on an adaptive dampening parameter $\tau_n$ which is
determined in each step via line search.
This ensures that the energy of the system
decreses with every iteration, guaranteeing convergence to a stable ground solution.
Once the value is deemed to be in a neighbourhood of the optimal solution $\hat{u}$
$\tau_n$ is set to $1$ to achieve the asymptotically fastest convergence rate.
For $tau_n = 1$ this method is the same as the inverse iteration algorithm.
- **Shifted Inverse Iteration**: This algorithm uses the **Rayleigh quotient**
to dynamically shift the operator at each step, aiming to accelerate convergence.

## Results and Analysis

The dampened and the normal inverse iteration show almost identical behaviour
with the normal version converging "smoother" than the dampened version.
For small nonlinearities the dampened version has a tiny edge, while for larger
nonlinearities the undampened version actually converges faster.
As-is there is no reason to use the dampened version. It may converge a tiny
bit faster for small nonlinearities, but it's not worth the overhead of the
line search algorithm.
Speaking of line search, this is probably the reason why the dampened version
looks so "bad". I used `scipy.optimize.minimize_scalar` instead of custom
line search algorithms which is probably not a good fit. Replacing
this with an alternative algorithm might lead to faster convergence.

While the normal and the dampened version of the inverse iteration both
seem to be working fine, this cannot be said about the shifted inverse iteration.
Convergence seems almost random and for some nonlinearity parameters it does not
converge at all. It seems the A-Method is not suited for shifting, which was
observed empirically for other problems as well.

## Project structure

- `gpe_algorithms.py`: Contains the implementations of the inverse iteration,
dampened inverse iteration, and shifted inverse iteration algorithms.
Also includes the energy functional calculation.
- `gpe_problem.py`: Defines the problem setup, including the discretization of the
2D Laplacian, the harmonic potential, and the construction of the nonlinear
operator $A(u)$.
- `main.ipynb`: A Jupyter Notebook for running the simulations, generating plots
and analyzing the results.
- `src/img`: The images generated by the jupyter notebook so the simulations
do not have to be re-run every time.

## How to run

1. Ensure you have the required Python packages: `numpy`, `scipy` and `matplotlib`
2. Run the main notebook to execute the algorithms and generate the convergence
plots.

## Possible Improvements

- There is a better alternative to the A-Method (called the J-Method) which uses the derivative
of the function (instead of just plugging $u$ into $A$) to better linearize
$A$ in each step. This could be implemented and compared to the A-Method.
Furthermore shifting with the J-Method is said to be highly effective (as opposed
to the A-Methods abysmal reaction to shifts).
- Replace `minimize_scalar` with custom line search algorithm to improve
performance of the dampened inverse iteration.
